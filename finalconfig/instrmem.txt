`timescale 1ns / 1ps

// define instruction memory variables
module instrmem(clk, addr, instr);

// defining clock
input clk;
wire clk;

// defin address as bus input
input [15:0] addr;

// define instruction as bus output
output reg [31:0] instr;

// define internal instruction record as array
reg [31:0] data [511:0];




// initialize instructions
initial
begin
	data[0] = {4'b1111,6'b000001,6'b000000,6'b000000,10'b0100000000};
	data[1] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000} /* 2 NOPS */;
	data[2] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000};
	data[3] = {4'b0101,6'b000010,6'b000001,6'b000000,10'b0000000000};
	data[4] = {4'b0110,6'b000011,6'b000001,6'b000000,10'b0000000000};
	data[5] = {4'b1111,6'b001010,6'b000000,6'b000000,10'b0000001000} /* PC + 8 (label1) */;
	data[6] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000};
	data[7] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000};
	data[8] = {4'b1011,6'b000000,6'b001010,6'b000000,10'b0000000000};
	data[9] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000} /* 3 NOPS */;
	data[10] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000};
	data[11] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000};
	data[12] = {4'b0101,6'b000010,6'b000010,6'b000000,10'b0000000000};
	data[13] = {4'b0011,6'b000000,6'b000001,6'b000001,10'b0000000000} /* label 1 */;
	data[14] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000} /* 2 NOPS */;
	data[15] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000};
	data[16] = {4'b1110,6'b000100,6'b000001,6'b000000,10'b0000000000};
	data[17] = {4'b0100,6'b000101,6'b000001,6'b000010,10'b0000000000};
	data[18] = {4'b0111,6'b000110,6'b000100,6'b000001,10'b0000000000};
	data[19] = {4'b1111,6'b001011,6'b000000,6'b000000,10'b0000001000} /* (label2) */;
	data[20] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000} /* 2 NOPS */;
	data[21] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000};
	data[22] = {4'b1001,6'b000000,6'b001011,6'b000000,10'b0000000000};
	data[23] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000} /* 3 NOPS */;
	data[24] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000};
	data[25] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000};
	data[26] = {4'b0101,6'b000010,6'b000010,6'b000000,10'b0000000000};
	data[27] = {4'b1010,6'b000000,6'b000001,6'b000000,10'b0100000000} /* label 2 */;
	data[28] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000} /* 3 NOPS */;
	data[29] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000};
	data[30] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000};
	data[256] = {4'b1000,6'b000000,6'b000001,6'b000000,10'b0000000000} /* 256 */;
	data[257] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000};
	data[258] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000};
	data[259] = {4'b0000,6'b000000,6'b000000,6'b000000,10'b0000000000};
end

// define behavior as clock rises:
always@(negedge clk)
begin

    instr = data[addr];
        
end
endmodule